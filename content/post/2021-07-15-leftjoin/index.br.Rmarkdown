---
title: "Como juntar conjuntos de dados no R. Parte I: dplyr::left_join()"
author: Santhiago Cristiano
date: '2021-07-16'
slug: []
categories:
  - R
tags:
  - joins
  - dplyr
  - left join
  - R
type: ''
subtitle: ''
image: ''
---

Neste primeiro post do site, demonstrarei como podemos juntar dois ou mais conjuntos de dados no R por meio de uma ou mais colunas em comum entre eles (chaves) utilizando a fun√ß√£o `left_join()` do pacote `{dplyr}`.


# Base de dados

Antes de tudo, precisamos obter nossos dados. Os dados para este post foram obtidos no DATASUS e correpondem aos √≥bitos infantis nos anos de 2010, 2011 e 2012. Os dados originais sem nenhuma modifica√ß√£o podem ser obtidos [aqui](https://datasus.saude.gov.br/mortalidade-desde-1996-pela-cid-10). Os dados que utilizarei como exemplo j√° passaram por uma breve limpeza e podem ser baixados no meu [GitHub](https://github.com/santhiago-cristiano/site-scripts/tree/main/2021/2021-07-16-leftjoin/dados).  

# Pacotes e cria√ß√£o do projeto

Inicialmente, recomendo a cria√ß√£o de um projeto. Se voc√™ n√£o sabe o que √©, como funciona, como criar ou por qual motivo voc√™ deveria passar a utilizar projetos no R, recomendo a leitura [deste cap√≠tulo do livro Zen do R](https://curso-r.github.io/zen-do-r/rproj-dir.html) escrito pelo pessoal da [Curso-R](https://curso-r.com/).

Dito isso, vamos carregar os pacotes que ser√£o utilizados:

```{r, message=FALSE, warning=FALSE}
library(readr)
library(dplyr)
library(abjData)
library(purrr)
library(glue)
```

Se ainda n√£o possui esses pacotes instalados, voc√™ pode instalar todos de uma s√≥ vez rodando o comando abaixo:

```{r, eval=FALSE}
install.packages(c("readr", "dplyr", "abjData", "purrr", "glue"))
```

# Importando os dados para o R

Para importar os dados para o R, primeiramente utilizamos a fun√ß√£o `list.files()`, que nos retorna um vetor com o caminho de todos os arquivos contidos em um determinado diret√≥rio, nesse caso, arquivos do tipo csv.

```{r}
# lista todos os arquivos csv contidos na minha pasta "dados/" 

arquivos_csv <- list.files(
  path = "./dados/",
  pattern = "*.csv",
  full.names = TRUE
)

arquivos_csv
```

Em seguida, podemos ler todos esses arquivos de uma tacada s√≥ utilizando a fun√ß√£o `read_csv2()` em conjunto com a `map()` dos pacotes `{readr}` e `{purrr}`, respectivamente. `read_csv2()` nos permite ler arquivos csv separados por `;` e o `map()` vai simplesmente aplicar essa fun√ß√£o em cada um dos tr√™s elementos do vetor `arquivos_csv` e nos retornar uma lista de data frames.  

```{r, message=FALSE, warning=FALSE}
# lendo todos os arquivos e armazenando em uma lista

morte_infantil <- map(
  arquivos_csv,
  read_csv2,
  locale(encoding = "latin1"),
  col_names = TRUE,
  col_types = "ccdi"
)

# atribuindo o ano como "nome" para cada um dos data frames da lista

names(morte_infantil) <- 2010:2012
```

Como argumentos para `read_csv2()` passamos o encoding dos nossos arquivos csv dentro da fun√ß√£o `locale()`, que neste caso √© `latin1`. O `latin1` √© apenas um dos diversos encodings existentes, para saber mais, [clique aqui](https://en.wikipedia.org/wiki/Character_encoding). Al√©m do encoding, passamos `col_names = TRUE`, para que a primeira linha dos nossos arquivos sejam reconhecidas como os nomes das colunas. Podemos ainda definir explicitamente o tipo de cada coluna com `col_types`. Nos dados temos 4 colunas, ent√£o, a primeira e a segunda coluna ser√£o do tipo `c = character`, a terceira do tipo `d = double` e a √∫ltima do tipo `i = integer`.

```{r}
# visualizando a lista
morte_infantil
```


Como pode ser visto, al√©m do total de mortes infantis e do ano, os dados do DATASUS cont√©m apenas os nomes dos munic√≠pios e os c√≥digos de 6 d√≠gitos referentes a cada um deles. Seria interessante tamb√©m adicionarmos as regi√µes e os estados e substituirmos o c√≥digo de 6 d√≠gitos pelo c√≥digo de 7 d√≠gitos do IBGE. Para isso, importaremos a base de dados `muni`, do pacote `{abjData}`, que cont√©m as colunas que desejamos acrescentar.

```{r}
glimpse(abjData::muni)
```

Essa base de dados completa possui muitas colunas, mas n√£o precisamos de todas elas. Para selecionar somente as colunas que desejamos, podemos utilizar a fun√ß√£o `select()` do `{dplyr}`. Aqui tamb√©m utilizo o [operador pipe (%>%)](https://www.datacamp.com/community/tutorials/pipe-r-tutorial) do `{magrittr}`.

```{r}
# carregando os dados auxiliares

auxiliar <- abjData::muni %>%
  select(muni_id, muni_id_6, uf_sigla, regiao_nm) %>%
  arrange(muni_id_6)
```

Dentro do `select()`, passamos como argumento os nomes das colunas que queremos selecionar:

- `muni_id`: c√≥digo de 7 d√≠gitos;
- `muni_id_6`: c√≥digo de 6 d√≠gitos que servir√° como chave para fazermos o join com nossa base de dados do DATASUS;
- `uf_sigla`e `regiao_nm`: siglas dos estados e nomes das regi√µes, respectivamente.

O `arrange()` est√° apenas ordenando os dados em ordem crescente de acordo com o c√≥digo de 6 d√≠gitos.

# dplyr::left_join()

A fun√ß√£o `left_join()` possui os seguintes argumentos:

`left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)`

Para o caso em quest√£o, precisamos somente dos tr√™s primeiros. `x` e `y`correspondem aos dois conjuntos de dados que desejamos juntar. Para o `by`, passamos o nome da coluna (ou colunas) que usaremos como chave para mesclar os dados. Quando o nome da coluna √© o mesmo em ambos, usamos somente `by = "nome da coluna"`, j√° quando os nomes das colunas s√£o diferentes, usamos `by = c("nome da coluna em x" = "nome da coluna em y")`.

O `left_join()` ir√° retornar todas as linhas de `x` e todas as colunas de `x` e `y`. As linhas em `x` que n√£o possuem uma correspondente em `y` s√£o preenchidas automaticamente com `NA`. Talvez tudo isso tenha ficado um pouco confuso, mas com exemplos pode ficar mais claro.

## Exemplo 1

Admita que tenhamos dois data frames ([tibbles](https://tibble.tidyverse.org/)), que chamarei de `tbl_1` e `tbl_2`:

```{r}
tbl_1 <- tibble::tribble(
  ~cpf, ~nome, ~idade,
  11111111111, "Maria", 25,
  22222222222, "Jos√©" , 40,
  33333333333, "Fran" , 23,
  44444444444, "J√µao" , 30,
)
tbl_1

tbl_2 <- tibble::tribble(
  ~cpf, ~cidade, ~estado,
  11111111111, "S√£o Paulo"     , "SP",
  22222222222, "Mossor√≥"       , "RN",
  33333333333, "Natal"         , "RN",
  44444444444, "Rio de Janeiro", "RJ",
)
tbl_2
```

Vamos supor que o primeiro cont√©m o CPF, nome e idade de clientes da empresa R & Python SA (pouco criativo, eu admito), enquanto o segundo cont√©m o CPF, a cidade e o estado onde cada um desses clientes moram. Agora suponha que desejamos reunir todas as informa√ß√µes dos clientes em um √∫nico data frame, acrescentando as colunas de cidade e estado da `tbl_2` na `tbl_1`. Como far√≠amos isso usando o `left_join()`?

Note que a coluna `cpf` √© comum em ambas as tabelas, portanto, podemos us√°-la como chave passando-a para o argumento `by`, dessa forma:

```{r}
left_join(x = tbl_1, y = tbl_2, by = "cpf")
```

Alternativamente, o mesmo resultado pode ser obtido utilizando o pipe `%>%`:

```{r}
tbl_1 %>% 
  left_join(tbl_2, by = "cpf")
```

Nesse exemplo, cada linha da coluna `cpf` da `tbl_1` possui uma linha id√™ntica na coluna `cpf` da `tbl_2`, por esse motivo, n√£o foi retornado nenhum valor `NA`. 

## Exemplo 2

Neste outro exemplo, farei algumas mudan√ßas nos dados:

```{r}
tbl_1 <- tibble::tribble(
  ~cpf, ~nome, ~idade,
  11111111111, "Maria", 25,
  22222222222, "Jos√©" , 40,
  33333333333, "Fran" , 23,
  44444444444, "J√µao" , 30,
  55555555555, "Messi", 34
)
tbl_1

tbl_2 <- tibble::tribble(
  ~cpf_cliente, ~cidade, ~estado,
  11111111111, "S√£o Paulo"     , "SP",
  22222222222, "Mossor√≥"       , "RN",
  33333333333, "Natal"         , "RN",
  44444444444, "Rio de Janeiro", "RJ",
  66666666666, "Recife"        , "PE"  
)
tbl_2
```

Observe agora que a coluna `cpf` da `tbl_1` est√° com uma linha a mais e que esta n√£o possui uma correspondente no segundo data frame. Al√©m disso, o nome da coluna com o CPF dos clientes est√° diferente na `tbl_2`. Neste caso, o join ficaria assim:

```{r}
tbl_1 %>% 
  left_join(tbl_2, by = c("cpf" = "cpf_cliente"))
```

Por fim, vale ressaltar que a ordem que passamos as tabelas no `left_join()` √© importante. O resultado seria diferente se fiz√©ssemos assim:

```{r}
tbl_2 %>% 
  left_join(tbl_1, by = c("cpf_cliente" = "cpf"))
```

No primeiro caso, todas as linhas da `tbl_1` s√£o retornadas, j√° no segundo, todas as linhas da `tbl_2` √© que s√£o retornadas. 

# Juntando os conjuntos de dados

Agora que importamos todos os dados que precisamos e sabemos como funciona o `left_join()`, podemos enfim juntar nossos dados do DATASUS com os da nossa base auxiliar. Neste caso, como coluna chave para a mesclagem utilizaremos `by = c("codigo" = "muni_id_6")`.

Uma das maneiras de fazer o left_join em nossos dados √© assim:

```{r, eval=FALSE}
# 2010
morte_infantil[["2010"]] <- morte_infantil[["2010"]] %>% 
  left_join(auxiliar, by = c("codigo" = "muni_id_6"))

# 2011
morte_infantil[["2011"]] <- morte_infantil[["2011"]] %>% 
  left_join(auxiliar, by = c("codigo" = "muni_id_6"))

# 2012
morte_infantil[["2012"]] <- morte_infantil[["2012"]] %>% 
  left_join(auxiliar, by = c("codigo" = "muni_id_6"))

```

No entanto, h√° uma outra forma de se fazer (que considero bem melhor) usando o `map()` do `{purrr}`. Para tanto, criarei uma fun√ß√£o que ter√° como argumento um data frame que chamarei de `x` (pode ser qualquer nome). Vou chamar essa fun√ß√£o de `mesclar_dados` (pode ser qualquer nome) e desejo que ela fa√ßa o seguinte:

- Join nos conjuntos de dados (`dplyr::left_join()`); 
- Ap√≥s o join, remova a coluna `codigo`, j√° que n√£o precisamos mais dela (`dplyr::select()`); 
- Renomeie as colunas `muni_id`, `uf_sigla` e `regiao_nm` (`dplyr::rename()`);
- Reposicione as colunas renomeadas para antes da coluna `municipio` (`dplyr::relocate()`).

```{r}
mesclar_dados <- function(x) {
  x %>%
    left_join(auxiliar, by = c("codigo" = "muni_id_6")) %>%
    select(-codigo) %>%
    rename(cod_ibge = muni_id, uf = uf_sigla, regiao = regiao_nm) %>%
    relocate(c(cod_ibge, regiao, uf), .before = municipio)
}
```

Criada a fun√ß√£o, agora podemos simplesmente passar a lista `morte_infantil` e a fun√ß√£o `mesclar_dados` como argumentos para o `map()` e ver a m√°gica acontecer:

```{r}
morte_infantil_mesclado <- map(morte_infantil, mesclar_dados)

morte_infantil_mesclado
```

Pronto! Simples assim! O `map()` aplicou a fun√ß√£o em cada um dos data frames contidos na lista e nos retornou uma outra lista com os data frames j√° mesclados. Agora temos as colunas `cod_ibge`, `regiao` e `uf` em todos os anos.

Por fim, se quisermos exportar os dados em um arquivo csv para cada ano, podemos usar mais uma incr√≠vel fun√ß√£o do `{purrr}`: a `walk()`. `walk()` funciona de forma semelhante ao `map()`, passamos como argumento a lista e a fun√ß√£o que desejamos aplicar nela, neste caso, a `write.csv2()`: 
 
```{r, eval=FALSE}
# com o pipe

morte_infantil_mesclado %>%
  names(.) %>%
  walk(~ write.csv2(
    morte_infantil_mesclado[[.]],
    file = glue("./dados-mesclados/{.}-mesclado.csv"),
    row.names = FALSE
  ))

# sem o pipe

walk(
  names(morte_infantil_mesclado),
  ~ write.csv2(
    morte_infantil_mesclado[[.]],
    file = glue("./dados-mesclados/{.}-mesclado.csv"),
    row.names = FALSE
  )
)
```

O caminho que passei no argumento `file` √© relativo ao meu projeto e pode ser diferente no seu caso. Se for, √© s√≥ substituir pelo caminho da pasta onde deseja salvar os arquivos exportados no seu computador. 

Se desejar "empilhar" todos os anos e exportar tudo em um √∫nico arquivo csv, use:

```{r, eval=FALSE}
map_dfr(morte_infantil, mesclar_dados) %>%
  write.csv2(file = "./dados-mesclados/mortes_infantis_mesclado.csv",
             row.names = FALSE)
```

Bom, por hoje s√≥. O c√≥digo completo dessa postagem est√° dispon√≠vel no meu [GitHub](https://github.com/santhiago-cristiano/site-scripts/tree/main/2021/2021-07-16-leftjoin). Na segunda parte darei continuidade falando sobre o `inner_join()`, que nos permite mesclar dois ou mais conjuntos de dados a partir de uma ou mais colunas chave mantendo somente as linhas que √© comum entre todos eles.

At√© a pr√≥xima üòÑ.

# Links √öteis

- https://readr.tidyverse.org/

- https://dplyr.tidyverse.org/

- https://dplyr.tidyverse.org/reference/join.html

- https://github.com/abjur/abjData

- https://purrr.tidyverse.org/

- https://glue.tidyverse.org/reference/glue.html

- https://tibble.tidyverse.org/

- https://magrittr.tidyverse.org/
