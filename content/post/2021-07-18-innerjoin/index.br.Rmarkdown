---
title: "Como juntar conjuntos de dados no R. Parte II: dplyr::inner_join()"
author: Santhiago Cristiano
date: '2021-07-20'
slug: []
categories:
  - R
tags:
  - dplyr
  - joins
  - R
  - inner join
type: ''
subtitle: ''
image: ''
---


Dando continuidade a s√©rie de posts sobre mesclagem de dados no R, hoje falarei sobre a fun√ß√£o `inner_join()` do pacote `{dplyr}`. Na [primeira parte](https://santhiago-cristiano.github.io/site/post/2021-07-15-leftjoin/), demonstrei como podemos mesclar dois ou mais conjuntos de dados usando a fun√ß√£o `left_join()` tamb√©m do `{dplyr}`

Bom, seguindo em frente, utilizarei os mesmos conjuntos de dados do [primeiro post](https://santhiago-cristiano.github.io/site/post/2021-07-15-leftjoin/), que podem ser baixados [clicando aqui](https://github.com/santhiago-cristiano/site-scripts/tree/main/2021/2021-07-16-leftjoin/dados-mesclados). Esses s√£o os dados que foram exportados ap√≥s feita a mesclagem utilizando `left_join()`.


# Pacotes e importa√ß√£o dos dados

Todo esse processo inicial √© semelhante ao do primeiro post: carregamos os pacotes que ser√£o usados e em seguida importamos os dados para o R. Como j√° descrevi esse processo com mais detalhes na [parte I](https://santhiago-cristiano.github.io/site/post/2021-07-15-leftjoin/), serei breve dessa vez para n√£o se tornar repetitivo.

```{r, message=FALSE, warning=FALSE}
library(readr)
library(dplyr)
library(purrr)
```

O `{readr}` serve para fazermos a leitura e importa√ß√£o dos dados para o R; o `{dplyr}` ;
e o `{purrr}` tem fun√ß√µes que simplificam o processo de loop e ser√° √∫til para importar todos os conjuntos de dados de uma √∫nica vez.

```{r, message=FALSE}
arquivos_csv <- list.files(
  path = "./dados/",
  pattern = "*.csv",
  full.names = TRUE
)

arquivos_csv

mortes_infantis <- map(
  arquivos_csv,
  read_csv2,
  locale(encoding = "latin1"),
  col_names = TRUE,
  col_types = "ccccdi"
) %>% 
  set_names(2010:2012)

mortes_infantis
```

A fun√ß√£o `list.files()` lista todos os arquivos csv contidos na pasta `"dados/"` e nos retorna um vetor, j√° a fun√ß√£o `purrr::map()` itera sobre cada elemento desse vetor e aplica a fun√ß√£o `readr::read_csv2()` em cada um deles nos retornando uma lista de data frames. 


# dplyr::inner_join()

A fun√ß√£o `inner_join()` possui os mesmos argumentos do `left_join()`:

`inner_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)`

A diferen√ßa entre as duas √© que, enquanto `left_join()` nos retorna todas as linhas de `x`, todas as colunas de `x` e `y` e preenche com `NA` as linhas em `x` que n√£o possuem uma correspondente em `y`, `inner_join()` retorna **somente as linhas de `x` onde existem valores correpondentes em `y`**, ou seja, teremos como retorno um novo conjunto de dados em que est√£o presentes somente as linhas que s√£o comuns entre ambos. Al√©m disso, `inner_join()` tamb√©m retorna todas as colunas de `x` e `y`.

Novamente, `x` e `y` correspondem aos conjuntos de dados que desejamos unir, enquanto `by` recebe o nome da coluna (ou colunas, pode ser mais de uma) que servir√° como chave para unir os dados. `by = "nome da coluna"` √© usado quando o nome da coluna √© o mesmo em ambos os conjuntos de dados, e `by = c("nome da coluna em x" = "nome da coluna em y")` quando os nomes das colunas s√£o diferentes. Como sempre, exemplos podem nos ajudar a entender melhor como as coisas acontecem.

## Exemplo

Admita que tenhamos dois conjuntos de dados com o desempenho dos alunos do ensino fundamental de determinada escola do Brasil em dois anos diferentes, 2019 e 2020, e desejamos unir esses dados trazendo somente os alunos que est√£o presentes nos dois anos para verificar se houve uma melhora ou piora no desempenho de cada um deles de um ano para o outro.

```{r}
alunos_2019 <- tibble::tribble(
  ~ matricula,   ~ nome,     ~ media,
  10,            "Jo√£o",     7.1,
  11,            "Jos√©",     8.5,
  12,            "Maria",    5.2
)

alunos_2020 <- tibble::tribble(
  ~ matricula,    ~ nome,       ~ media,
  9,              "Joana",      8.0,
  10,             "Jo√£o",       9.0,     
  11,             "Jos√©",       5.4,
  12,             "Maria",      8.7,
  13,             "Ana",        10.0,
  14,             "Francisco",  4.3
)
```


Podemos utilizar a coluna com o n√∫mero da matr√≠cula como chave para unir os dados, passando-a para o argumento `by`

```{r}
alunos_2019 %>%
  inner_join(alunos_2020, by = "matricula")
```

Repare que, como as colunas `nome` e `media` existem nas duas tabelas, √© acrescentado automaticamente um sufixo em cada uma delas para evitar nomes de colunas repetidos. Nesse caso, `.x` √© o sufixo referente as colunas do data frame `alunos_2019` e `.y` √© o sufixo referente as colunas de `alunos_2020`. √â poss√≠vel alterar esses nomes passando os sufixos que desejamos acrescentar para o argumento `suffix`. Dessa forma:

```{r}
alunos_2019 %>%
  inner_join(alunos_2020, by = "matricula", suffix = c("_2019", "_2020"))
```

Note que a ordem que os sufixos s√£o passados importa! Como os dados referentes ao ano de 2019 vem primeiro, passamos primeiro o sufixo de 2019 e depois o de 2020. Se fosse ao contr√°rio, seria assim:

```{r}
alunos_2020 %>%
  inner_join(alunos_2019, by = "matricula", suffix = c("_2020", "_2019"))
```

# Juntando os conjuntos de dados

Feito essa explica√ß√£o, agora vamos juntar os conjuntos de dados que foram importados l√° no √≠nicio mantendo somente os munic√≠pios que est√£o presentes em todos os anos (2010, 2011 e 2012). Como chave para unir os dados, utilizarei a coluna `cod_ibge`, que possui o c√≥digo IBGE de 7 dig√≠tos para cada munic√≠pio.

Uma das maneiras de unir nossos dados √© assim:

```{r, eval=FALSE}
mortes_infantis_inner <- mortes_infantis[["2010"]] %>%
  inner_join(
    mortes_infantis[["2011"]],
    by = "cod_ibge",
    suffix = c("_2010", "_2011")
  ) %>%
  inner_join(mortes_infantis[["2012"]], by = "cod_ibge")

```

Ok. Parece bom. Mas e se pud√©ssemos simplificar isso deixando nosso c√≥digo mais limpo e leg√≠vel? Com `purrr::reduce()` isso √© poss√≠vel!

```{r}
mortes_infantis_inner <- reduce(mortes_infantis,
                                inner_join, by = "cod_ibge",
                                suffix = c("_2010", "_2011"))
```

Para a fun√ß√£o `reduce()` passamos a lista que cont√©m os data frames que queremos juntar e a fun√ß√£o `inner_join()` com os seus devidos argumentos. Simples assim! √â incr√≠vel O que conseguimos fazer utilizando o `{purrr}`, pretendo demonstrar um pouco mais do seu "poder" em um post futuro.

Agora temos um novo conjunto de dados que cont√©m somente os munic√≠pios que estavam presentes em todos os anos:

```{r}
glimpse(mortes_infantis_inner)
```
Como era esperado, foi acrescentado o sufixo `_2010` para as colunas do ano 2010 e `_2011` para as colunas do ano 2011. As √∫ltimas 5 colunas sem sufixo, s√£o referentes ao ano de 2012. Note que agora temos diversas colunas com regi√£o, UF e munic√≠pio, como nesse caso sei que o conte√∫do √© o mesmo para todas elas, podemos jogar fora essa colunas repetidas:

```{r}
mortes_infantis_inner <- mortes_infantis_inner %>%
  select(
    !(contains(c("regiao", "uf", "municipio", "ano")) &
      ends_with(c("_2010", "_2011"))),
    -ano
  ) %>%
  rename(total_2012 = total) %>%
  relocate(c(regiao, uf, municipio), .after = cod_ibge)
```

Para remover todas as colunas desejadas, pe√ßo para a fun√ß√£o `select()` do `{dplyr}` selecionar somente as colunas que **ao mesmo tempo** n√£o contenham as palavras `"regiao"`, `"uf"`, `"municipio"` e `"ano"` **e** termine com os sufixos `"_2010"` ou `"_2011"`. Al√©m disso, apenas renomeio e reposiciono outras colunas com `dplyr::rename()` e `dplyr::relocate()`, respectivamente.

```{r}
glimpse(mortes_infantis_inner)
```

Conclu√≠do todos os passos, agora √© s√≥ exportar os dados:

```{r, eval=FALSE}
write.csv2(
  mortes_infantis_inner,
  file = "./dados-inner/mortes_infantis_inner.csv",
  row.names = FALSE
)
```

√â isso. Finalizo por aqui. O c√≥digo completo desse post est√° dispon√≠vel no meu [GitHub](https://github.com/santhiago-cristiano/site-scripts/tree/main/2021/2021-07-20-innerjoin).

At√© a pr√≥xima üëã. 

# Links √öteis

- https://readr.tidyverse.org/

- https://dplyr.tidyverse.org/

- https://dplyr.tidyverse.org/reference/join.html

- https://purrr.tidyverse.org/
